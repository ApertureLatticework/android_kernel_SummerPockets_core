From 1237417a06a305b585ce4252af88767324b73600 Mon Sep 17 00:00:00 2001
From: Kinaxie <huanying1194139625@gmail.com>
Date: Sat, 21 Jun 2025 14:49:15 +0800
Subject: [PATCH] f2fs: Optimize f2fs_bmap with get_data_block_bmap for faster
 app cold starts

Introduce get_data_block_bmap to replace f2fs_map_blocks in f2fs_bmap for
non-compressed files, streamlining single-block mapping operations. The new
function uses f2fs_get_dnode_of_data with struct dnode_of_data to directly
retrieve block addresses, reducing the overhead of initializing struct
f2fs_map_blocks for bmap's single-block queries. This minimizes CPU and memory
usage, enhancing performance in everyday Android scenarios like application cold
starts (e.g., launching WeChat or TikTok), file manager operations, and media
playback, where fast block mapping improves user experience. Logic for inline
data, dirty page writeback, and compressed files remains unchanged, with
trace_f2fs_bmap preserved for debugging.

Signed-off-by: Kinaxie <huanying1194139625@gmail.com>
---
 fs/f2fs/data.c | 85 ++++++++++++++++++++++++++++++++------------------
 1 file changed, 55 insertions(+), 30 deletions(-)

diff --git a/fs/f2fs/data.c b/fs/f2fs/data.c
index fa16590efa88..f2095d59a8d6 100644
--- a/fs/f2fs/data.c
+++ b/fs/f2fs/data.c
@@ -1870,6 +1870,37 @@ static inline u64 blks_to_bytes(struct inode *inode, u64 blks)
 	return (blks << inode->i_blkbits);
 }
 
+static int get_data_block_bmap(struct inode *inode, sector_t iblock,
+        struct buffer_head *bh_result, int create)
+{
+    struct dnode_of_data dn;
+    int ret;
+
+    if (unlikely(iblock >= max_file_blocks(inode)))
+        return -EFBIG;
+
+    /* Get data block address */
+    set_new_dnode(&dn, inode, NULL, NULL, 0);
+    ret = f2fs_get_dnode_of_data(&dn, iblock, 0);
+    if (ret)
+        goto out;
+
+    if (dn.data_blkaddr == NULL_ADDR) {
+        ret = -ENOENT;
+        goto put_dnode;
+    }
+
+    /* Set buffer_head result */
+    set_buffer_mapped(bh_result);
+    bh_result->b_blocknr = dn.data_blkaddr;
+    bh_result->b_size = inode->i_sb->s_blocksize;
+
+put_dnode:
+    f2fs_put_dnode(&dn);
+out:
+    return ret;
+}
+
 static int f2fs_xattr_fiemap(struct inode *inode,
 				struct fiemap_extent_info *fieinfo)
 {
@@ -3813,37 +3844,31 @@ static sector_t f2fs_bmap_compress(struct inode *inode, sector_t block)
 
 static sector_t f2fs_bmap(struct address_space *mapping, sector_t block)
 {
-	struct inode *inode = mapping->host;
-	sector_t blknr = 0;
-
-	if (f2fs_has_inline_data(inode))
-		goto out;
-
-	/* make sure allocating whole blocks */
-	if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
-		filemap_write_and_wait(mapping);
-
-	/* Block number less than F2FS MAX BLOCKS */
-	if (unlikely(block >= max_file_blocks(inode)))
-		goto out;
-
-	if (f2fs_compressed_file(inode)) {
-		blknr = f2fs_bmap_compress(inode, block);
-	} else {
-		struct f2fs_map_blocks map;
-
-		memset(&map, 0, sizeof(map));
-		map.m_lblk = block;
-		map.m_len = 1;
-		map.m_next_pgofs = NULL;
-		map.m_seg_type = NO_CHECK_TYPE;
-
-		if (!f2fs_map_blocks(inode, &map, F2FS_GET_BLOCK_BMAP))
-			blknr = map.m_pblk;
-	}
+    struct inode *inode = mapping->host;
+    sector_t blknr = 0;
+    struct buffer_head bh_result;
+
+    if (f2fs_has_inline_data(inode))
+        goto out;
+
+    /* make sure allocating whole blocks */
+    if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
+        filemap_write_and_wait(mapping);
+
+    /* Block number less than F2FS MAX BLOCKS */
+    if (unlikely(block >= max_file_blocks(inode)))
+        goto out;
+
+    if (f2fs_compressed_file(inode)) {
+        blknr = f2fs_bmap_compress(inode, block);
+    } else {
+        memset(&bh_result, 0, sizeof(bh_result));
+        if (!get_data_block_bmap(inode, block, &bh_result, 0))
+            blknr = bh_result.b_blocknr;
+    }
 out:
-	trace_f2fs_bmap(inode, block, blknr);
-	return blknr;
+    trace_f2fs_bmap(inode, block, blknr);
+    return blknr;
 }
 
 #ifdef CONFIG_SWAP
