From dab73a2562de6e0f44a0091c98c897bc186c133d Mon Sep 17 00:00:00 2001
From: EmanuelCN <emanuelghub@gmail.com>
Date: Sun, 10 Aug 2025 01:49:30 +0000
Subject: [PATCH] sched/fair: Set sched tunable scaling to none

Android sets it to none in their init and its over never honored because sched_debug is disabled.
---
 kernel/sched/fair.c |   2 +-
 nohup.out           | 171 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 172 insertions(+), 1 deletion(-)
 create mode 100644 nohup.out

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index a56bed1d0daa..a4723a8c0dd1 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -88,7 +88,7 @@ static unsigned int normalized_sysctl_sched_latency	= 6000000ULL;
  *
  * (default SCHED_TUNABLESCALING_LOG = *(1+ilog(ncpus))
  */
-unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_LOG;
+unsigned int sysctl_sched_tunable_scaling = SCHED_TUNABLESCALING_NONE;
 
 /*
  * Minimal preemption granularity for CPU-bound tasks:
diff --git a/nohup.out b/nohup.out
new file mode 100644
index 000000000000..6f2859f159d9
--- /dev/null
+++ b/nohup.out
@@ -0,0 +1,171 @@
+---
+ drivers/remoteproc/Kconfig            |  8 ------
+ drivers/remoteproc/qcom_q6v5_pas.c    | 36 ++++++++++++---------------
+ include/linux/remoteproc/qcom_rproc.h | 13 +++-------
+ 3 files changed, 19 insertions(+), 38 deletions(-)
+
+diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
+index 05b5ec2a47b52..99ed01c8cce73 100644
+--- a/drivers/remoteproc/Kconfig
++++ b/drivers/remoteproc/Kconfig
+@@ -167,14 +167,6 @@ config QCOM_PIL_INFO
+ config QCOM_RPROC_COMMON
+ 	tristate "Qualcomm Technologies, Inc. Remote Proc Common Framework"
+ 
+-config QCOM_Q6V5_PAS_SOCCP_V1
+-	bool "SOCCP V1"
+-	help
+-	  Support to enable power state transition control of SoC Control Processor
+-	  V1 via an API which can be used by clients to vote for the subsystem to
+-	  be either in active or dormant states.
+-	  If unsure say N.
+-
+ config QCOM_Q6V5_COMMON
+ 	tristate
+ 	depends on ARCH_QCOM
+diff --git a/drivers/remoteproc/qcom_q6v5_pas.c b/drivers/remoteproc/qcom_q6v5_pas.c
+index 9c3033b067436..e4299ffd09201 100644
+--- a/drivers/remoteproc/qcom_q6v5_pas.c
++++ b/drivers/remoteproc/qcom_q6v5_pas.c
+@@ -5,7 +5,7 @@
+  * Copyright (C) 2016 Linaro Ltd
+  * Copyright (C) 2014 Sony Mobile Communications AB
+  * Copyright (c) 2012-2013, 2020-2021, The Linux Foundation. All rights reserved.
+- * Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
++ * Copyright (c) 2022-2025 Qualcomm Innovation Center, Inc. All rights reserved.
+  */
+ 
+ #include <linux/clk.h>
+@@ -985,7 +985,6 @@ static int rproc_find_status_register(struct qcom_adsp *adsp)
+ 	return 0;
+ }
+ 
+-#if IS_ENABLED(CONFIG_QCOM_Q6V5_PAS_SOCCP_V1)
+ static bool rproc_poll_handover(struct qcom_adsp *adsp)
+ {
+ 	unsigned int retry_num = 50;
+@@ -1136,7 +1135,6 @@ int rproc_set_state(struct rproc *rproc, bool state)
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(rproc_set_state);
+-#endif
+ 
+ static int rproc_panic_handler(struct notifier_block *this,
+ 			      unsigned long event, void *ptr)
+@@ -1146,24 +1144,22 @@ static int rproc_panic_handler(struct notifier_block *this,
+ 
+ 	if (!adsp)
+ 		return NOTIFY_DONE;
+-	if (adsp->check_status) {
+-		/* wake up SOCCP during panic to run error handlers on SOCCP */
+-		dev_info(adsp->dev, "waking SOCCP from panic path\n");
+-		ret = qcom_smem_state_update_bits(adsp->wake_state,
+-						SOCCP_STATE_MASK,
+-						BIT(adsp->wake_bit));
+-		if (ret) {
+-			dev_err(adsp->dev, "failed to update smem bits for D3 to D0\n");
+-			goto done;
+-		}
+-		ret = rproc_config_check_atomic(adsp, SOCCP_D0, adsp->tcsr_addr);
+-		if (ret)
+-			dev_err(adsp->dev, "failed to change to D0\n");
+-
+-		ret = rproc_config_check_atomic(adsp, SPARE_REG_SOCCP_D0, adsp->spare_reg_addr);
+-		if (ret)
+-			dev_err(adsp->dev, "failed to change to D0\n");
++	/* wake up SOCCP during panic to run error handlers on SOCCP */
++	dev_info(adsp->dev, "waking SOCCP from panic path\n");
++	ret = qcom_smem_state_update_bits(adsp->wake_state,
++				    SOCCP_STATE_MASK,
++				    BIT(adsp->wake_bit));
++	if (ret) {
++		dev_err(adsp->dev, "failed to update smem bits for D3 to D0\n");
++		goto done;
+ 	}
++	ret = rproc_config_check_atomic(adsp, SOCCP_D0, adsp->tcsr_addr);
++	if (ret)
++		dev_err(adsp->dev, "failed to change to D0\n");
++
++	ret = rproc_config_check_atomic(adsp, SPARE_REG_SOCCP_D0, adsp->spare_reg_addr);
++	if (ret)
++		dev_err(adsp->dev, "failed to change to D0\n");
+ done:
+ 	return NOTIFY_DONE;
+ }
+diff --git a/include/linux/remoteproc/qcom_rproc.h b/include/linux/remoteproc/qcom_rproc.h
+index 894d609361494..11a83323b8db6 100644
+--- a/include/linux/remoteproc/qcom_rproc.h
++++ b/include/linux/remoteproc/qcom_rproc.h
+@@ -1,6 +1,6 @@
+ /* SPDX-License-Identifier: GPL-2.0-only */
+ /*
+- *  Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
++ * Copyright (c) 2022-2023, 2025 Qualcomm Innovation Center, Inc. All rights reserved.
+  */
+ 
+ #ifndef __QCOM_RPROC_H__
+@@ -31,24 +31,17 @@ struct qcom_ssr_notify_data {
+ 	bool crashed;
+ };
+ 
+-#if IS_ENABLED(CONFIG_QCOM_Q6V5_PAS_SOCCP_V1)
++#if IS_ENABLED(CONFIG_QCOM_Q6V5_PAS)
+ 
+ extern bool power_state_hibernate;
+ int rproc_set_state(struct rproc *rproc, bool state);
++int qcom_rproc_set_dtb_firmware(struct rproc *rproc, const char *dtb_fw_name);
+ 
+ #else
+-
+ static inline int rproc_set_state(struct rproc *rproc, bool state)
+ {
+ 	return 0;
+ }
+-#endif
+-
+-#if IS_ENABLED(CONFIG_QCOM_Q6V5_PAS)
+-
+-int qcom_rproc_set_dtb_firmware(struct rproc *rproc, const char *dtb_fw_name);
+-
+-#else
+ 
+ static inline int qcom_rproc_set_dtb_firmware(struct rproc *rproc, const char *dtb_fw_name)
+ {
+-- 
+GitLab
+
+---
+ drivers/usb/dwc3/dwc3-msm-core.c | 8 ++------
+ 1 file changed, 2 insertions(+), 6 deletions(-)
+
+diff --git a/drivers/usb/dwc3/dwc3-msm-core.c b/drivers/usb/dwc3/dwc3-msm-core.c
+index f8476037685c0..d24e0fcf792fd 100644
+--- a/drivers/usb/dwc3/dwc3-msm-core.c
++++ b/drivers/usb/dwc3/dwc3-msm-core.c
+@@ -6813,10 +6813,8 @@ static int dwc3_msm_probe(struct platform_device *pdev)
+ 
+ put_dwc3:
+ 	usb_role_switch_unregister(mdwc->role_switch);
+-	for (i = 0; i < ARRAY_SIZE(mdwc->icc_paths); i++) {
++	for (i = 0; i < ARRAY_SIZE(mdwc->icc_paths); i++)
+ 		icc_put(mdwc->icc_paths[i]);
+-			mdwc->icc_paths[i] = NULL;
+-	}
+ 
+ err:
+ 	destroy_workqueue(mdwc->sm_usb_wq);
+@@ -6902,10 +6900,8 @@ static int dwc3_msm_remove(struct platform_device *pdev)
+ 	pm_runtime_set_suspended(mdwc->dev);
+ 	device_wakeup_disable(mdwc->dev);
+ 
+-	for (i = 0; i < ARRAY_SIZE(mdwc->icc_paths); i++) {
++	for (i = 0; i < ARRAY_SIZE(mdwc->icc_paths); i++)
+ 		icc_put(mdwc->icc_paths[i]);
+-		mdwc->icc_paths[i] = NULL;
+-	}
+ 
+ 	vbus_regulator_toggle(mdwc, false);
+ 
+-- 
+GitLab
+
